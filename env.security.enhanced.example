# Enhanced Security Configuration Template
# Copy this to your .env file and update with actual values

# ============================================================================
# EXISTING SECURITY (Already Implemented)
# ============================================================================

# Enable authentication (JWT or API keys)
A2A_REQUIRE_AUTH=true

# Enable rate limiting
A2A_ENABLE_RATE_LIMIT=true
A2A_RATE_LIMIT_PER_MINUTE=300

# Enable replay protection
A2A_ENABLE_REPLAY_PROTECTION=true
A2A_REPLAY_TTL_SECONDS=120

# JWT Configuration
A2A_JWT_ISSUER=ca-a2a
A2A_JWT_ALG=RS256
A2A_JWT_MAX_SKEW_SECONDS=30
A2A_JWT_MAX_TOKEN_AGE_SECONDS=120

# Public/Private keys for JWT (RS256)
# Generate with: openssl genrsa -out private.pem 2048
#               openssl rsa -in private.pem -pubout -out public.pem
A2A_JWT_PUBLIC_KEY_PEM=/path/to/public.pem
A2A_JWT_PRIVATE_KEY_PEM=/path/to/private.pem

# API Keys (JSON format)
# Example: {"lambda-s3-processor":"key1","orchestrator":"key2"}
A2A_API_KEYS_JSON={}

# RBAC Policy (JSON format)
# Example: {"allow":{"lambda-s3-processor":["*"]},"deny":{}}
A2A_RBAC_POLICY_JSON={"allow":{},"deny":{}}


# ============================================================================
# NEW SECURITY FEATURES (Enhanced Implementation)
# ============================================================================

# ─────────────────────────────────────────────────────────────────────────
# 1. HMAC REQUEST SIGNING (Message Integrity Protection)
# ─────────────────────────────────────────────────────────────────────────

# Enable HMAC signature verification on incoming requests
A2A_ENABLE_HMAC_SIGNING=true

# Secret key for HMAC (64+ characters recommended)
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(64))"
A2A_HMAC_SECRET_KEY=CHANGE_ME_64_PLUS_CHARACTERS_SECRET_KEY_FOR_HMAC_SIGNING

# Maximum age of HMAC signature in seconds (replay protection)
A2A_HMAC_MAX_AGE_SECONDS=300


# ─────────────────────────────────────────────────────────────────────────
# 2. JSON SCHEMA VALIDATION (Input Validation)
# ─────────────────────────────────────────────────────────────────────────

# Enable JSON Schema validation for all method parameters
A2A_ENABLE_SCHEMA_VALIDATION=true

# Schemas are defined in a2a_security_enhanced.py:JSONSchemaValidator.SCHEMAS
# No additional configuration needed


# ─────────────────────────────────────────────────────────────────────────
# 3. TOKEN REVOCATION (Dynamic Credential Revocation)
# ─────────────────────────────────────────────────────────────────────────

# Enable JWT token revocation checking
A2A_ENABLE_TOKEN_REVOCATION=true

# Database connection for persistent revocation list
# If not provided, uses in-memory cache (lost on restart)
# Database schema will be created automatically
DATABASE_URL=postgresql://user:password@host:5432/dbname

# Cleanup interval for expired revocations (seconds)
A2A_REVOCATION_CLEANUP_INTERVAL=300


# ─────────────────────────────────────────────────────────────────────────
# 4. mTLS CERTIFICATE AUTHENTICATION (Certificate-Based Trust)
# ─────────────────────────────────────────────────────────────────────────

# Enable mutual TLS certificate authentication
A2A_ENABLE_MTLS=true

# Path to CA certificate for verifying client certificates
# Generate CA with: openssl req -x509 -new -nodes -key ca-key.pem -sha256 -days 1024 -out ca-cert.pem
A2A_MTLS_CA_CERT_PATH=/path/to/ca-cert.pem

# Path to server certificate (for agents acting as servers)
A2A_MTLS_SERVER_CERT_PATH=/path/to/server-cert.pem
A2A_MTLS_SERVER_KEY_PATH=/path/to/server-key.pem

# Path to client certificate (for agents acting as clients)
A2A_MTLS_CLIENT_CERT_PATH=/path/to/client-cert.pem
A2A_MTLS_CLIENT_KEY_PATH=/path/to/client-key.pem


# ============================================================================
# RECOMMENDED CONFIGURATIONS
# ============================================================================

# ─────────────────────────────────────────────────────────────────────────
# Development Environment
# ─────────────────────────────────────────────────────────────────────────
# A2A_REQUIRE_AUTH=false
# A2A_ENABLE_HMAC_SIGNING=false
# A2A_ENABLE_SCHEMA_VALIDATION=true  # Keep this on
# A2A_ENABLE_TOKEN_REVOCATION=false
# A2A_ENABLE_MTLS=false


# ─────────────────────────────────────────────────────────────────────────
# Staging Environment
# ─────────────────────────────────────────────────────────────────────────
# A2A_REQUIRE_AUTH=true
# A2A_ENABLE_HMAC_SIGNING=true
# A2A_ENABLE_SCHEMA_VALIDATION=true
# A2A_ENABLE_TOKEN_REVOCATION=true
# A2A_ENABLE_MTLS=false  # Optional


# ─────────────────────────────────────────────────────────────────────────
# Production Environment (All Security Features)
# ─────────────────────────────────────────────────────────────────────────
# A2A_REQUIRE_AUTH=true
# A2A_ENABLE_HMAC_SIGNING=true
# A2A_ENABLE_SCHEMA_VALIDATION=true
# A2A_ENABLE_TOKEN_REVOCATION=true
# A2A_ENABLE_MTLS=true  # Highest security


# ============================================================================
# SECURITY BEST PRACTICES
# ============================================================================

# 1. Rotate all secrets every 90 days minimum
# 2. Use AWS Secrets Manager for production secrets
# 3. Never commit .env files to version control
# 4. Use different secrets for dev/staging/production
# 5. Monitor audit logs for suspicious activity
# 6. Enable all security features in production
# 7. Use RS256 (not HS256) for JWT in production
# 8. Keep certificates in secure locations with restricted permissions
# 9. Use strong secrets (64+ characters, random)
# 10. Test security features regularly


# ============================================================================
# QUICK SETUP COMMANDS
# ============================================================================

# Generate HMAC secret:
# python -c "import secrets; print(secrets.token_urlsafe(64))"

# Generate JWT key pair:
# openssl genrsa -out private.pem 2048
# openssl rsa -in private.pem -pubout -out public.pem

# Generate CA certificate for mTLS:
# openssl genrsa -out ca-key.pem 4096
# openssl req -x509 -new -nodes -key ca-key.pem -sha256 -days 1024 -out ca-cert.pem

# Generate agent certificate signed by CA:
# openssl genrsa -out agent-key.pem 2048
# openssl req -new -key agent-key.pem -out agent.csr
# openssl x509 -req -in agent.csr -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -out agent-cert.pem -days 365 -sha256

# Initialize revocation database schema:
# python -c "from a2a_security_enhanced import init_revocation_schema; import asyncpg; import asyncio; asyncio.run(init_revocation_schema(asyncpg.create_pool('postgresql://...')))"


# ============================================================================
# PERFORMANCE NOTES
# ============================================================================

# Expected overhead per request:
# - HMAC signing/verification: ~0.5ms
# - JSON Schema validation: ~0.5ms
# - Token revocation check (memory): ~0.01ms
# - Token revocation check (database): ~2ms
# - mTLS verification: ~1-2ms
# Total: ~2-5ms additional latency (acceptable for most use cases)


# ============================================================================
# TROUBLESHOOTING
# ============================================================================

# HMAC verification fails:
# - Check A2A_HMAC_SECRET_KEY matches on both sides
# - Check clock synchronization (max 30s skew)
# - Check signature not expired (A2A_HMAC_MAX_AGE_SECONDS)

# Schema validation fails:
# - Check method parameters match schemas in JSONSchemaValidator.SCHEMAS
# - Check for additional properties (not allowed by default)
# - Check enum values are exact matches

# Token revocation not working:
# - Check database connection (DATABASE_URL)
# - Check revoked_tokens table exists (run init_revocation_schema)
# - Check A2A_ENABLE_TOKEN_REVOCATION=true

# mTLS verification fails:
# - Check CA certificate path (A2A_MTLS_CA_CERT_PATH)
# - Check certificate not expired
# - Check certificate chain is valid
# - Check Common Name (CN) in certificate

